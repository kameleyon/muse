// src/services/exportService.ts
import { formatForPdfExport, cleanupJsonCodeBlocks } from '@/utils/markdownFormatter';
import jsPDF from 'jspdf';
import { marked } from 'marked';
import 'jspdf-autotable'; // Import for better table support

// Placeholder for API base URL
const API_BASE_URL = '/api/export';

// --- Types ---
export type ExportFormat = 'pptx' | 'pdf' | 'google_slides' | 'html5' | 'video' | 'mobile' | 'print'; // Export type

interface ExportOptions {
  format: ExportFormat;
  versionId?: string; // Optional: specify version to export
  options?: {
    password?: string;
    tracking?: boolean;
    quality?: 'high' | 'standard';
    includeNotes?: boolean;
  };
}

export interface ExportResult { // Export interface
  downloadUrl?: string; // URL to download the exported file
  shareUrl?: string; // URL for sharing (e.g., Google Slides)
  status: 'pending' | 'processing' | 'completed' | 'failed';
  jobId?: string; // ID to track async export jobs
}

// --- API Functions ---

/**
 * Initiates an export job for a project.
 * @param projectId - The ID of the project to export.
 * @param options - Export configuration options.
 * @returns Promise resolving to the initial export status or result.
 */
export const exportProject = async (projectId: string, options: ExportOptions): Promise<ExportResult> => {
  console.log('API CALL: exportProject', projectId, options);
  // Replace with actual fetch/axios call
  // This might be an async job, returning a jobId initially
  await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate job start delay
  
  // Simulate immediate completion for simple formats, or pending for complex ones
  if (options.format === 'pdf' || options.format === 'pptx') {
    return { 
      status: 'completed', 
      downloadUrl: `/exports/${projectId}_${options.format}_${Date.now()}.${options.format === 'pdf' ? 'pdf' : 'pptx'}` 
    };
  } else {
     return { status: 'pending', jobId: `export_${Date.now()}` };
  }
};

/**
 * Checks the status of an asynchronous export job.
 * @param jobId - The ID of the export job.
 * @returns Promise resolving to the current export status or result.
 */
export const getExportStatus = async (jobId: string): Promise<ExportResult> => {
  console.log('API CALL: getExportStatus', jobId);
   // Replace with actual fetch/axios call
  await new Promise(resolve => setTimeout(resolve, 500)); 
  // Simulate progress -> completion
  if (Math.random() > 0.3) { // Simulate still processing
     return { status: 'processing', jobId };
  } else {
     // Simulate completion (determine format based on jobId or another way)
     const format = 'google_slides'; // Example
     return { 
       status: 'completed', 
       shareUrl: `https://docs.google.com/presentation/d/example_${jobId}`, 
       jobId 
     };
  }
};

/**
 * Generates a PDF with proper markdown formatting and color application
 * @param projectId - The ID of the project.
 * @param content - The content to format and export as PDF.
 * @param brandColors - Optional brand colors to apply to the PDF.
 * @returns Promise resolving to the export result.
 */
// Define the brand colors interface
interface BrandColors {
  primary?: string;
  secondary?: string;
  accent?: string;
  title?: string;
}

export const generateFormattedPdf = async (
  projectId: string,
  content: string,
  brandColors?: BrandColors
): Promise<ExportResult> => {
  console.log('API CALL: generateFormattedPdf', projectId);
  
  try {
    // First clean up any JSON code blocks in the content
    const cleanedContent = cleanupJsonCodeBlocks(content);
    
    // Then convert to markdown with proper formatting
    const markdownContent = formatForPdfExport(cleanedContent, brandColors);
    
    // Convert markdown to HTML for better parsing
    const htmlContent = marked(markdownContent) as string;
    
    // Create a new PDF document
    const doc = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });
    
    // Set document properties
    const title = brandColors?.title || `MagicMuse Document - ${projectId}`;
    doc.setProperties({
      title: title,
      subject: 'Generated by MagicMuse',
      author: 'MagicMuse',
      keywords: 'MagicMuse, PDF, Document',
      creator: 'MagicMuse PDF Generator'
    });
    
    // Get colors from brandColors or use defaults
    const primaryColor = brandColors?.primary || '#ae5630';
    const secondaryColor = brandColors?.secondary || '#232321';
    
    // Convert hex colors to RGB for jsPDF
    const hexToRgb = (hex: string) => {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : { r: 0, g: 0, b: 0 };
    };
    
    const primaryRgb = hexToRgb(primaryColor);
    const secondaryRgb = hexToRgb(secondaryColor);
    
    // Add title page
    doc.setFontSize(24);
    doc.setTextColor(primaryRgb.r, primaryRgb.g, primaryRgb.b);
    doc.text(title, 105, 30, { align: 'center', maxWidth: 170 });
    
    doc.setFontSize(12);
    doc.setTextColor(secondaryRgb.r, secondaryRgb.g, secondaryRgb.b);
    doc.text(`Generated: ${new Date().toLocaleDateString()}`, 105, 45, { align: 'center' });
    
    // Add a divider line
    doc.setDrawColor(primaryRgb.r, primaryRgb.g, primaryRgb.b);
    doc.setLineWidth(0.5);
    doc.line(20, 50, 190, 50);
    
    // Parse the HTML content to extract sections
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlContent;
    
    // Start content on a new page
    doc.addPage();
    
    // Track current Y position
    let yPos = 20;
    const margin = 20;
    const pageWidth = doc.internal.pageSize.getWidth();
    const contentWidth = pageWidth - (margin * 2);
    
    // Process each element
    const elements = Array.from(tempDiv.children);
    
    for (const element of elements) {
      // Check if we need a new page
      if (yPos > 270) {
        doc.addPage();
        yPos = 20;
      }
      
      // Process based on element type
      if (element.tagName === 'H1') {
        doc.setFontSize(20);
        doc.setTextColor(primaryRgb.r, primaryRgb.g, primaryRgb.b);
        doc.text(element.textContent || '', margin, yPos);
        yPos += 10;
        
        // Add underline for h1
        doc.setDrawColor(primaryRgb.r, primaryRgb.g, primaryRgb.b);
        doc.setLineWidth(0.5);
        doc.line(margin, yPos, margin + contentWidth * 0.5, yPos);
        yPos += 5;
      } 
      else if (element.tagName === 'H2') {
        doc.setFontSize(18);
        doc.setTextColor(primaryRgb.r, primaryRgb.g, primaryRgb.b);
        doc.text(element.textContent || '', margin, yPos);
        yPos += 8;
      } 
      else if (element.tagName === 'H3') {
        doc.setFontSize(16);
        doc.setTextColor(primaryRgb.r, primaryRgb.g, primaryRgb.b);
        doc.text(element.textContent || '', margin, yPos);
        yPos += 7;
      } 
      else if (element.tagName === 'P') {
        doc.setFontSize(12);
        doc.setTextColor(0, 0, 0);
        const text = element.textContent || '';
        const splitText = doc.splitTextToSize(text, contentWidth);
        doc.text(splitText, margin, yPos);
        yPos += (splitText.length * 7);
      } 
      else if (element.tagName === 'UL' || element.tagName === 'OL') {
        doc.setFontSize(12);
        doc.setTextColor(0, 0, 0);
        
        const listItems = Array.from(element.querySelectorAll('li'));
        for (let i = 0; i < listItems.length; i++) {
          const item = listItems[i];
          const prefix = element.tagName === 'OL' ? `${i + 1}. ` : 'â€¢ ';
          const text = item.textContent || '';
          const splitText = doc.splitTextToSize(text, contentWidth - 10);
          
          // Check if we need a new page
          if (yPos + (splitText.length * 7) > 270) {
            doc.addPage();
            yPos = 20;
          }
          
          doc.text(prefix, margin, yPos);
          doc.text(splitText, margin + 7, yPos);
          yPos += (splitText.length * 7);
        }
      } 
      else if (element.tagName === 'TABLE') {
        // Use jspdf-autotable for better table rendering
        try {
          // Extract table data
          const tableRows: string[][] = [];
          const tableHeaders: string[] = [];
          
          // Get headers
          const headerRow = element.querySelector('thead tr');
          if (headerRow) {
            const headers = Array.from(headerRow.querySelectorAll('th'));
            headers.forEach(header => {
              tableHeaders.push(header.textContent || '');
            });
          }
          
          // Get rows
          const rows = Array.from(element.querySelectorAll('tbody tr'));
          rows.forEach(row => {
            const cells = Array.from(row.querySelectorAll('td'));
            const rowData: string[] = [];
            cells.forEach(cell => {
              rowData.push(cell.textContent || '');
            });
            tableRows.push(rowData);
          });
          
          // Check if we need a new page
          if (yPos + (tableRows.length * 10) + 20 > 270) {
            doc.addPage();
            yPos = 20;
          }
          
          // @ts-ignore - jspdf-autotable extends jsPDF prototype
          doc.autoTable({
            head: tableHeaders.length > 0 ? [tableHeaders] : undefined,
            body: tableRows,
            startY: yPos,
            theme: 'grid',
            headStyles: {
              fillColor: [primaryRgb.r, primaryRgb.g, primaryRgb.b],
              textColor: [255, 255, 255],
              fontStyle: 'bold'
            },
            alternateRowStyles: {
              fillColor: [245, 245, 245]
            },
            margin: { left: margin, right: margin }
          });
          
          // Update yPos after table
          // @ts-ignore - jspdf-autotable extends jsPDF prototype
          yPos = doc.lastAutoTable.finalY + 10;
        } catch (tableError) {
          console.error('Error rendering table:', tableError);
          yPos += 10;
        }
      } 
      else if (element.tagName === 'BLOCKQUOTE') {
        doc.setFontSize(12);
        doc.setTextColor(100, 100, 100);
        // @ts-ignore - setFontStyle exists on jsPDF
        doc.setFontStyle('italic');
        
        const text = element.textContent || '';
        const splitText = doc.splitTextToSize(text, contentWidth - 10);
        
        // Draw quote line
        doc.setDrawColor(primaryRgb.r, primaryRgb.g, primaryRgb.b);
        doc.setLineWidth(1);
        doc.line(margin, yPos, margin, yPos + (splitText.length * 7));
        
        doc.text(splitText, margin + 5, yPos);
        yPos += (splitText.length * 7) + 5;
        
        // @ts-ignore - setFontStyle exists on jsPDF
        doc.setFontStyle('normal');
      } 
      else if (element.tagName === 'HR') {
        doc.setDrawColor(200, 200, 200);
        doc.setLineWidth(0.5);
        doc.line(margin, yPos, margin + contentWidth, yPos);
        yPos += 5;
      } 
      else {
        // Default handling for other elements
        if (element.textContent && element.textContent.trim()) {
          doc.setFontSize(12);
          doc.setTextColor(0, 0, 0);
          const text = element.textContent.trim();
          const splitText = doc.splitTextToSize(text, contentWidth);
          doc.text(splitText, margin, yPos);
          yPos += (splitText.length * 7);
        }
      }
      
      // Add some spacing between elements
      yPos += 5;
    }
    
    // Add footer to all pages
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(10);
      doc.setTextColor(150, 150, 150);
      doc.text(`Generated by MagicMuse | Page ${i} of ${pageCount}`, 105, 285, { align: 'center' });
    }
    
    // Generate a blob URL for the PDF
    const pdfBlob = doc.output('blob');
    const blobUrl = URL.createObjectURL(pdfBlob);
    
    return {
      status: 'completed',
      downloadUrl: blobUrl
    };
  } catch (error) {
    console.error('PDF generation failed:', error);
    return { status: 'failed' };
  }
};

// Add more functions as needed (batchExport, getExportHistory, etc.)