// src/services/exportService.ts
import { formatForPdfExport } from '@/utils/markdownFormatter';
import jsPDF from 'jspdf';

// Placeholder for API base URL
const API_BASE_URL = '/api/export';

// --- Types ---
export type ExportFormat = 'pptx' | 'pdf' | 'google_slides' | 'html5' | 'video' | 'mobile' | 'print'; // Export type

interface ExportOptions {
  format: ExportFormat;
  versionId?: string; // Optional: specify version to export
  options?: {
    password?: string;
    tracking?: boolean;
    quality?: 'high' | 'standard';
    includeNotes?: boolean;
  };
}

export interface ExportResult { // Export interface
  downloadUrl?: string; // URL to download the exported file
  shareUrl?: string; // URL for sharing (e.g., Google Slides)
  status: 'pending' | 'processing' | 'completed' | 'failed';
  jobId?: string; // ID to track async export jobs
}

// --- API Functions ---

/**
 * Initiates an export job for a project.
 * @param projectId - The ID of the project to export.
 * @param options - Export configuration options.
 * @returns Promise resolving to the initial export status or result.
 */
export const exportProject = async (projectId: string, options: ExportOptions): Promise<ExportResult> => {
  console.log('API CALL: exportProject', projectId, options);
  // Replace with actual fetch/axios call
  // This might be an async job, returning a jobId initially
  await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate job start delay
  
  // Simulate immediate completion for simple formats, or pending for complex ones
  if (options.format === 'pdf' || options.format === 'pptx') {
    return { 
      status: 'completed', 
      downloadUrl: `/exports/${projectId}_${options.format}_${Date.now()}.${options.format === 'pdf' ? 'pdf' : 'pptx'}` 
    };
  } else {
     return { status: 'pending', jobId: `export_${Date.now()}` };
  }
};

/**
 * Checks the status of an asynchronous export job.
 * @param jobId - The ID of the export job.
 * @returns Promise resolving to the current export status or result.
 */
export const getExportStatus = async (jobId: string): Promise<ExportResult> => {
  console.log('API CALL: getExportStatus', jobId);
   // Replace with actual fetch/axios call
  await new Promise(resolve => setTimeout(resolve, 500)); 
  // Simulate progress -> completion
  if (Math.random() > 0.3) { // Simulate still processing
     return { status: 'processing', jobId };
  } else {
     // Simulate completion (determine format based on jobId or another way)
     const format = 'google_slides'; // Example
     return { 
       status: 'completed', 
       shareUrl: `https://docs.google.com/presentation/d/example_${jobId}`, 
       jobId 
     };
  }
};

/**
 * Generates a PDF with proper markdown formatting and color application
 * @param projectId - The ID of the project.
 * @param content - The content to format and export as PDF.
 * @param brandColors - Optional brand colors to apply to the PDF.
 * @returns Promise resolving to the export result.
 */
// Define the brand colors interface
interface BrandColors {
  primary?: string;
  secondary?: string;
  accent?: string;
  title?: string;
}

export const generateFormattedPdf = async (
  projectId: string,
  content: string,
  brandColors?: BrandColors
): Promise<ExportResult> => {
  console.log('API CALL: generateFormattedPdf', projectId);
  
  try {
    // First convert HTML content to properly formatted markdown
    const markdownContent = formatForPdfExport(content, brandColors);
    
    // Use jsPDF to generate a PDF
    const doc = new jsPDF();
    
    // Set up document properties
    const title = brandColors?.title || `MagicMuse Document - ${projectId}`;
    doc.setProperties({
      title: title,
      subject: 'Generated by MagicMuse',
      author: 'MagicMuse',
      keywords: 'MagicMuse, PDF, Document',
      creator: 'MagicMuse PDF Generator'
    });
    
    // Set up fonts and colors
    doc.setFont('helvetica');
    doc.setTextColor(0, 0, 0);
    
    // Add title
    doc.setFontSize(24);
    doc.text(title, 20, 20);
    
    // Add date
    doc.setFontSize(12);
    doc.text(`Generated: ${new Date().toLocaleDateString()}`, 20, 30);
    
    // Add content
    doc.setFontSize(12);
    
    // Split the content into lines that fit the page width
    const textLines = doc.splitTextToSize(markdownContent, 170);
    
    // Add the text lines to the PDF, starting at y-position 40
    doc.text(textLines, 20, 40);
    
    // Generate a blob URL for the PDF
    const pdfBlob = doc.output('blob');
    const blobUrl = URL.createObjectURL(pdfBlob);
    
    // In a real implementation, we would save this to a server
    // For now, we'll just return the blob URL
    
    return {
      status: 'completed',
      downloadUrl: blobUrl
    };
  } catch (error) {
    console.error('PDF generation failed:', error);
    return { status: 'failed' };
  }
};

// Add more functions as needed (batchExport, getExportHistory, etc.)