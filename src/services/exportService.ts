// src/services/exportService.ts
import { formatForPdfExport } from '@/utils/markdownFormatter';
import jsPDF from 'jspdf';

// Placeholder for API base URL
const API_BASE_URL = '/api/export';

// --- Types ---
export type ExportFormat = 'pptx' | 'pdf' | 'google_slides' | 'html5' | 'video' | 'mobile' | 'print'; // Export type

interface ExportOptions {
  format: ExportFormat;
  versionId?: string; // Optional: specify version to export
  options?: {
    password?: string;
    tracking?: boolean;
    quality?: 'high' | 'standard';
    includeNotes?: boolean;
  };
}

export interface ExportResult { // Export interface
  downloadUrl?: string; // URL to download the exported file
  shareUrl?: string; // URL for sharing (e.g., Google Slides)
  status: 'pending' | 'processing' | 'completed' | 'failed';
  jobId?: string; // ID to track async export jobs
}

// --- API Functions ---

/**
 * Initiates an export job for a project.
 * @param projectId - The ID of the project to export.
 * @param options - Export configuration options.
 * @returns Promise resolving to the initial export status or result.
 */
export const exportProject = async (projectId: string, options: ExportOptions): Promise<ExportResult> => {
  console.log('API CALL: exportProject', projectId, options);
  // Replace with actual fetch/axios call
  // This might be an async job, returning a jobId initially
  await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate job start delay
  
  // Simulate immediate completion for simple formats, or pending for complex ones
  if (options.format === 'pdf' || options.format === 'pptx') {
    return { 
      status: 'completed', 
      downloadUrl: `/exports/${projectId}_${options.format}_${Date.now()}.${options.format === 'pdf' ? 'pdf' : 'pptx'}` 
    };
  } else {
     return { status: 'pending', jobId: `export_${Date.now()}` };
  }
};

/**
 * Checks the status of an asynchronous export job.
 * @param jobId - The ID of the export job.
 * @returns Promise resolving to the current export status or result.
 */
export const getExportStatus = async (jobId: string): Promise<ExportResult> => {
  console.log('API CALL: getExportStatus', jobId);
   // Replace with actual fetch/axios call
  await new Promise(resolve => setTimeout(resolve, 500)); 
  // Simulate progress -> completion
  if (Math.random() > 0.3) { // Simulate still processing
     return { status: 'processing', jobId };
  } else {
     // Simulate completion (determine format based on jobId or another way)
     const format = 'google_slides'; // Example
     return { 
       status: 'completed', 
       shareUrl: `https://docs.google.com/presentation/d/example_${jobId}`, 
       jobId 
     };
  }
};

/**
 * Generates a PDF with proper markdown formatting and color application
 * @param projectId - The ID of the project.
 * @param content - The content to format and export as PDF.
 * @param brandColors - Optional brand colors to apply to the PDF.
 * @returns Promise resolving to the export result.
 */
// Define the brand colors interface
interface BrandColors {
  primary?: string;
  secondary?: string;
  accent?: string;
  title?: string;
}

export const generateFormattedPdf = async (
  projectId: string,
  content: string,
  brandColors?: BrandColors
): Promise<ExportResult> => {
  console.log('API CALL: generateFormattedPdf', projectId);
  
  try {
    // First convert HTML content to properly formatted markdown
    const markdownContent = formatForPdfExport(content, brandColors);
    
    // Use jsPDF to generate a PDF
    const doc = new jsPDF();
    
    // Set up document properties
    const title = brandColors?.title || `MagicMuse Document - ${projectId}`;
    doc.setProperties({
      title: title,
      subject: 'Generated by MagicMuse',
      author: 'MagicMuse',
      keywords: 'MagicMuse, PDF, Document',
      creator: 'MagicMuse PDF Generator'
    });
    
    // Set up fonts and colors
    doc.setFont('helvetica');
    doc.setTextColor(0, 0, 0);
    
    // Add title
    doc.setFontSize(24);
    doc.text(title, 20, 20);
    
    // Add date
    doc.setFontSize(12);
    doc.text(`Generated: ${new Date().toLocaleDateString()}`, 20, 30);
    
    // Add content with proper markdown formatting
    doc.setFontSize(12);
    
    // Process markdown content for better PDF rendering
    const processedContent = markdownContent
      // Remove any problematic code blocks that might be causing issues
      .replace(/```([\s\S]*?)```/g, (match, codeContent) => {
        if (codeContent.includes('"type":') || codeContent.includes('function')) {
          return '[Code block removed for PDF export]';
        }
        return match;
      });
    
    // Split content by headers to handle them specially
    const contentSections = processedContent.split(/^(#+\s.*?)$/m);
    
    let yPosition = 40; // Starting y position
    const pageWidth = doc.internal.pageSize.getWidth();
    const margin = 20;
    const textWidth = pageWidth - (margin * 2);
    
    // Process each section
    for (let i = 0; i < contentSections.length; i++) {
      const section = contentSections[i];
      
      // Skip empty sections
      if (!section.trim()) continue;
      
      // Check if this is a header
      if (/^#+\s/.test(section)) {
        // Determine header level
        const headerLevel = (section.match(/^#+/) || [''])[0].length;
        const headerText = section.replace(/^#+\s/, '');
        
        // Set font size based on header level
        if (headerLevel === 1) {
          doc.setFontSize(20);
          doc.setTextColor(0, 0, 0);
        } else if (headerLevel === 2) {
          doc.setFontSize(18);
          doc.setTextColor(40, 40, 40);
        } else {
          doc.setFontSize(16);
          doc.setTextColor(60, 60, 60);
        }
        
        // Add header text
        const headerLines = doc.splitTextToSize(headerText, textWidth);
        doc.text(headerLines, margin, yPosition);
        yPosition += (headerLines.length * (headerLevel === 1 ? 10 : 8)) + 5;
        
        // Reset font for normal text
        doc.setFontSize(12);
        doc.setTextColor(0, 0, 0);
      } else {
        // Process regular content
        // Split the content into lines that fit the page width
        const textLines = doc.splitTextToSize(section, textWidth);
        
        // Check if we need a new page
        if (yPosition + (textLines.length * 7) > doc.internal.pageSize.getHeight() - margin) {
          doc.addPage();
          yPosition = margin + 10;
        }
        
        // Add the text lines to the PDF
        doc.text(textLines, margin, yPosition);
        yPosition += (textLines.length * 7) + 10;
      }
    }
    
    // Generate a blob URL for the PDF
    const pdfBlob = doc.output('blob');
    const blobUrl = URL.createObjectURL(pdfBlob);
    
    // In a real implementation, we would save this to a server
    // For now, we'll just return the blob URL
    
    return {
      status: 'completed',
      downloadUrl: blobUrl
    };
  } catch (error) {
    console.error('PDF generation failed:', error);
    return { status: 'failed' };
  }
};

// Add more functions as needed (batchExport, getExportHistory, etc.)